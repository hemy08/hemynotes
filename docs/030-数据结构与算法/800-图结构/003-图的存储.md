# 图的存储

## 一、邻接矩阵

### 1.1 定义

图的邻接矩阵\(Adjacency Matrix\) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组\(称为邻接矩阵\)存储图中的边或弧的信息。

邻接矩阵是表示图中顶点之间相邻关系的矩阵。设图G有n个顶点，则邻接矩阵是一个n×n的方阵，其中元素A\[i\]\[j\]表示顶点i和顶点j之间的关系。对于无权图，A\[i\]\[j\]的值为1或0，1表示顶点i和j之间有边，0表示没有边。对于带权图，A\[i\]\[j\]的值可以是权值，用一个特定的值（如无穷大）表示没有边。

=== "G是无权图"

    ```plaintext
    A[i][j] = 1，当顶点vi与vj之间有边时
    A[i][j] = 0，当顶点vi与vj之间没有边时
    ```
    
=== "G是带权图"

    ```plaintext
    A[i][j] = wij，当顶点vi与vj之间有边且权值为wij时
    A[i][j] = ∞（或0），当顶点vi与vj之间没有边时
    A[i][i] = 0（或∞），对角线元素处理方式
    ```
### 1.2 数据结构实现

=== "C语言的邻接矩阵"

    ```c
    #include <stdio.h>
    #include <limits.h>
    
    #define MAX_VERTEX_NUM 100
    #define INFINITY INT_MAX  // 表示无穷大
    
    // 无权图的邻接矩阵
    typedef struct {
      char vexs[MAX_VERTEX_NUM];           // 顶点表
      int arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];  // 邻接矩阵
      int vexnum, arcnum;                  // 顶点数和边数
    } MGraph;
    
    // 带权图的邻接矩阵
    typedef struct {
      char vexs[MAX_VERTEX_NUM];           // 顶点表
      int arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];  // 邻接矩阵，存储权值
      int vexnum, arcnum;                  // 顶点数和边数
    } WeightedMGraph;
    ```
    
=== "C语言的邻接矩阵"

    ```cpp
    #include <vector>
    #include <iostream>
    using namespace std;
    
    template<typename T>
    class AdjacencyMatrix {
    private:
        vector<T> vertices;           // 顶点集合
        vector<vector<int>> matrix;   // 邻接矩阵
        int vertexCount;              // 顶点数量
        bool weighted;                // 是否带权
        int noEdgeValue;              // 无边时的值
    
    public:
        // 构造函数
        AdjacencyMatrix(int n, bool isWeighted = false, int noEdge = 0) 
            : vertexCount(n), weighted(isWeighted), noEdgeValue(noEdge) {
            vertices.resize(n);
            matrix.resize(n, vector<int>(n, noEdge));
            
            // 如果是带权图，对角线设为0，否则设为noEdge
            for (int i = 0; i < n; i++) {
                matrix[i][i] = weighted ? 0 : noEdge;
            }
        }
        
        // 其他成员函数...
    };
    ```

### 1.3 邻接矩阵示例

=== "无向无权图"

    ```mermaid
    graph LR
        A --- B
        A --- C
        B --- C
        B --- D
        C --- D
    ```
    
    邻接矩阵
    
    ```text
           0  1  2  3
        0  0  1  1  0
        1  1  0  1  1  
        2  1  1  0  1
        3  0  1  1  0
    ````

    特点：
    
    - 矩阵对称：A[i][j] = A[j][i]
    - 对角线为0（无自环）

=== "有向无权图"

    ```mermaid
    graph LR
        A --> B
        A --> C
        B --> D
        C --> B
        C --> D
    ```
    
    邻接矩阵
    
    ```text
           0  1  2  3
        0  0  1  1  0
        1  0  0  0  1  
        2  0  1  0  1
        3  0  0  0  0
    ````

    特点：
    
    - 矩阵不对称
    - 行为出度，列为入度

=== "带权有向图"

    ```mermaid
    graph LR
        A --> B
        A --> C
        B --> D
        C --> B
        C --> D
    ```
    
    邻接矩阵
    
    ```text
           0  1  2  3
        0  0  1  1  0
        1  0  0  0  1  
        2  0  1  0  1
        3  0  0  0  0
    ````

### 1.4 邻接矩阵完整实现示例

=== "C语言实现"

=== "C++语言实现"

    **实现说明：**
    
    **数据结构：**
    
        - ```vertices```：存储顶点标识符的向量
        - ```adjMatrix```：二维向量存储边权值
        - ```vertexCount```：当前顶点数
        
    **核心接口：**
    
        - ```addVertex(char)```：添加新顶点
        - ```addEdge(char, char, int)```：添加边（默认权值1）
        - ```getVertexIndex(char)```：通过顶点值获取索引
        - ```getFirstAdjacent(int)```：获取某顶点的第一个邻接点索引
        - ```getNextAdjacent(int, int)```：获取下一个邻接点索引
        
    **特点分析：**
    
        - 空间复杂度：O(n²)，适合稠密图
        - 边查询时间复杂度：O(1)
        - 顶点插入：O(1)（不考虑扩容）
        - 邻接点遍历：O(n)
        
    **使用示例输出：**
    ```
            A B C D 
            A 0 4 2 0 
            B 4 0 0 5 
            C 2 0 0 3 
            D 0 5 3 0 
        顶点C的第一个邻接点: A
        下一个邻接点: D
    ```
    
    **扩展建议：**
        - 添加删除顶点/边功能
        - 支持带权图/无权图切换
        - 增加图遍历算法（DFS/BFS）

    ```cpp
    #include <iostream>
    #include <vector>
    #include <stdexcept>
    using namespace std;
    
    class Graph {
    private:
        vector<char> vertices;       // 顶点集合
        vector<vector<int>> adjMatrix; // 邻接矩阵
        int vertexCount = 0;         // 当前顶点数
    
    public:
        // 创建图：初始化顶点容量
        Graph(int maxVertices) {
            adjMatrix.resize(maxVertices, vector<int>(maxVertices, 0));
        }
    
        // 添加顶点
        void addVertex(char vertex) {
            if(vertexCount >= adjMatrix.size()) {
                throw overflow_error("图已达到最大顶点容量");
            }
            vertices.push_back(vertex);
            vertexCount++;
        }
    
        // 添加边（无向图）
        void addEdge(char v1, char v2, int weight = 1) {
            int idx1 = getVertexIndex(v1);
            int idx2 = getVertexIndex(v2);
            if(idx1 == -1 || idx2 == -1) throw invalid_argument("顶点不存在");
    
            adjMatrix[idx1][idx2] = weight;
            adjMatrix[idx2][idx1] = weight; // 有向图需删除此行
        }
    
        // 获取顶点位置
        int getVertexIndex(char vertex) const {
            for(int i = 0; i < vertexCount; i++) {
                if(vertices[i] == vertex) return i;
            }
            return -1;
        }
    
        // 获取第一个邻接点
        int getFirstAdjacent(int vertexIdx) const {
            if(vertexIdx < 0 || vertexIdx >= vertexCount) 
                throw out_of_range("顶点索引越界");
    
            for(int j = 0; j < vertexCount; j++) {
                if(adjMatrix[vertexIdx][j] != 0) return j;
            }
            return -1; // 无邻接点
        }
    
        // 获取下一个邻接点
        int getNextAdjacent(int vertexIdx, int currentAdj) const {
            if(vertexIdx < 0 || vertexIdx >= vertexCount || 
               currentAdj < 0 || currentAdj >= vertexCount)
                throw out_of_range("索引越界");
    
            for(int j = currentAdj + 1; j < vertexCount; j++) {
                if(adjMatrix[vertexIdx][j] != 0) return j;
            }
            return -1; // 无后续邻接点
        }
    
        // 打印邻接矩阵
        void printMatrix() const {
            cout << "  ";
            for(const auto& v : vertices) cout << v << " ";
            cout << "\n";
    
            for(int i = 0; i < vertexCount; i++) {
                cout << vertices[i] << " ";
                for(int j = 0; j < vertexCount; j++) {
                    cout << adjMatrix[i][j] << " ";
                }
                cout << "\n";
            }
        }
    };
    
    // 使用示例
    int main() {
        // 创建最大容量为5的图
        Graph graph(5);
        
        // 添加顶点
        graph.addVertex('A');
        graph.addVertex('B');
        graph.addVertex('C');
        graph.addVertex('D');
        
        // 添加边
        graph.addEdge('A', 'B', 4);
        graph.addEdge('A', 'C', 2);
        graph.addEdge('B', 'D', 5);
        graph.addEdge('C', 'D', 3);
        
        // 打印邻接矩阵
        graph.printMatrix();
        
        // 查询顶点C的邻接点
        int cIndex = graph.getVertexIndex('C');
        cout << "\n顶点C的第一个邻接点: " << vertices[graph.getFirstAdjacent(cIndex)] << endl;
        
        int adj = graph.getFirstAdjacent(cIndex);
        while(adj != -1) {
            cout << "下一个邻接点: " << vertices[adj] << endl;
            adj = graph.getNextAdjacent(cIndex, adj);
        }
    
        return 0;
    }
    ```

## 二、领接表

## 三、十字链表

## 四、领接多重表

## 五、边集数组
